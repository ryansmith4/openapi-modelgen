plugins {
    alias(libs.plugins.gradle.plugin.publish)
    id 'java-gradle-plugin'
    id 'groovy'
    alias(libs.plugins.spotbugs)
    alias(libs.plugins.owasp.dependencycheck)
    id 'checkstyle'
}

import com.github.spotbugs.snom.Effort
import com.github.spotbugs.snom.Confidence

repositories {
    mavenLocal()
    gradlePluginPortal()
    mavenCentral()
}

dependencies {
    implementation gradleApi()
    
    // OpenAPI Generator plugin as compileOnly - available for compilation but not bundled
    // Consumer projects must provide their own version (7.10.0+)
    compileOnly libs.openapi.generator.gradle.plugin.compat
    
    // OpenAPI Generator core for CodegenConfig API - also compileOnly
    compileOnly libs.openapi.generator.compat
    
    // Static analysis annotations for @SuppressFBWarnings - compileOnly so not bundled
    compileOnly libs.spotbugs.annotations
    
    // Plugin core dependencies (includes security-critical versions)
    implementation libs.bundles.plugin.core
    
    // For TestKit tests, we need the OpenAPI Generator plugin available in the test runtime
    testRuntimeOnly libs.openapi.generator.gradle.plugin
    testImplementation libs.openapi.generator.gradle.plugin
    testImplementation libs.openapi.generator
    testImplementation libs.bundles.plugin.test
    testImplementation gradleTestKit()
}

// Force dependency resolution for security vulnerabilities
configurations.all {
    resolutionStrategy {
        // CVE-2025-48924: Force commons-lang3 to secure version 3.18.0+
        force 'org.apache.commons:commons-lang3:3.18.0'

        // Explicit resolution for all commons-lang3 transitive dependencies
        eachDependency { DependencyResolveDetails details ->
            if (details.requested.group == 'org.apache.commons' &&
                details.requested.name == 'commons-lang3') {
                details.useVersion '3.18.0'
                details.because 'Security fix for CVE-2025-48924 - Uncontrolled Recursion vulnerability'
            }
        }
    }
}

// Configure compilation warnings
compileJava {
    options.compilerArgs += ['-Xlint:deprecation', '-Xlint:unchecked']
    options.deprecation = true
}

// Configure test execution
test {
    useJUnitPlatform()
    
    // Set system properties for TestKit
    systemProperty 'gradle.user.home', gradle.gradleUserHomeDir
    
    // Configure test execution
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat "full"
        showStandardStreams = false
    }
    
    // Increase timeout for integration tests
    timeout = Duration.ofMinutes(5)
}

// Checkstyle configuration for code style enforcement
checkstyle {
    toolVersion = '11.0.1'  // Updated to latest version to fix CVE-2025-48734 in commons-beanutils
    configFile = file("${projectDir}/config/checkstyle/checkstyle.xml")
    configDirectory = file("${projectDir}/config/checkstyle")
    ignoreFailures = true   // Don't fail build on style violations (for now)
    // maxWarnings = 0      // Commented out - too strict for existing codebase
    // maxErrors = 0        // Commented out - too strict for existing codebase
}

// SpotBugs configuration for code quality
spotbugs {
    toolVersion = '4.8.6'  // Use stable version that works with plugin
    effort = com.github.spotbugs.snom.Effort.valueOf('MAX')
    reportLevel = com.github.spotbugs.snom.Confidence.valueOf('LOW')
    ignoreFailures = true  // Don't fail build, just report issues
    if (file("${projectDir}/spotbugs-exclude.xml").exists()) {
        excludeFilter = file("${projectDir}/spotbugs-exclude.xml")
    }
}

spotbugsMain {
    reports {
        html {
            required = true
            outputLocation = file("${buildDir}/reports/spotbugs/main.html")
            stylesheet = 'fancy-hist.xsl'
        }
        xml {
            required = true
            outputLocation = file("${buildDir}/reports/spotbugs/main.xml")
        }
        sarif {
            required = false
        }
    }
}

spotbugsTest {
    reports {
        html {
            required = true
            outputLocation = file("${buildDir}/reports/spotbugs/test.html")
            stylesheet = 'fancy-hist.xsl'
        }
        xml {
            required = false
        }
    }
}

// Make check task depend on SpotBugs
check.dependsOn spotbugsMain

// OWASP Dependency Check configuration for security scanning
dependencyCheck {
    analyzedTypes = ['jar']
    skipConfigurations = ['testImplementation', 'testCompileOnly']
    
    formats = ['HTML', 'XML', 'JSON']
    outputDirectory = file("$buildDir/reports/security")
    
    suppressionFile = file('owasp-suppressions.xml')
    
    failBuildOnCVSS = 7.0  // Fail on HIGH severity or above
    
    // Disable problematic analyzers - we only care about Java JAR dependencies
    analyzers {
        assemblyEnabled = false
        nodeEnabled = false
    }
    
    nvd {
        // NVD API configuration - use environment variable or gradle property
        apiKey = providers.gradleProperty('nvdApiKey').orElse(
            providers.environmentVariable('NVD_API_KEY')
        ).getOrNull()
        delay = 2000  // Delay between API calls (milliseconds)
    }
    
    // Cache directory configuration
    data {
        directory = file("${System.getProperty('user.home')}/.gradle/dependency-check-data")
    }
    
    // Auto-update settings
    autoUpdate = true
}

// Manual security scanning - NOT integrated into build lifecycle
// Run manually before releases: ./gradlew preReleaseSecurityScan
tasks.register('preReleaseSecurityScan') {
    group = 'release'
    description = 'Run security scan before preparing release'
    
    doFirst {
        // Check API key availability and provide clear feedback
        def apiKeyFromGradleProps = providers.gradleProperty('nvdApiKey').getOrNull()
        def apiKeyFromEnv = providers.environmentVariable('NVD_API_KEY').getOrNull()
        def cacheDir = file("${System.getProperty('user.home')}/.gradle/dependency-check-data")
        
        println "üîç Starting OWASP Dependency Check Security Scan"
        println "=" * 60
        
        // API Key Status with validation
        def effectiveKey = null
        def effectiveSource = null
        
        if (apiKeyFromGradleProps != null && !apiKeyFromGradleProps.trim().isEmpty()) {
            effectiveKey = apiKeyFromGradleProps.trim()
            effectiveSource = "Gradle property"
        } else if (apiKeyFromEnv != null && !apiKeyFromEnv.trim().isEmpty()) {
            effectiveKey = apiKeyFromEnv.trim()
            effectiveSource = "Environment variable"
        }
        
        if (effectiveKey != null) {
            println "‚úÖ NVD API Key: FOUND from ${effectiveSource}"
            println "   Expected performance: 5-10 minutes first run, <30 seconds cached"
            
            // Log precedence if both are available
            if (apiKeyFromGradleProps != null && !apiKeyFromGradleProps.trim().isEmpty() && 
                apiKeyFromEnv != null && !apiKeyFromEnv.trim().isEmpty()) {
                println "   Note: Both sources available - Gradle property takes precedence"
            }
        } else {
            println "‚ö†Ô∏è  NVD API Key: NOT FOUND or BLANK"
            println "   Expected performance: 15-30 minutes (may timeout on slow connections)"
            println "   üí° Get an API key: https://nvd.nist.gov/developers/request-an-api-key"
            println "   üí° Add Gradle property: -PnvdApiKey=your-key OR gradle.properties: nvdApiKey=your-key"
            println "   üí° Or set environment variable: export NVD_API_KEY=your-key"
            
            // Specific warnings for blank keys
            if (apiKeyFromGradleProps != null && apiKeyFromGradleProps.trim().isEmpty()) {
                println "   ‚ö†Ô∏è  Note: Gradle property 'nvdApiKey' is set but blank"
            }
            if (apiKeyFromEnv != null && apiKeyFromEnv.trim().isEmpty()) {
                println "   ‚ö†Ô∏è  Note: Environment variable 'NVD_API_KEY' is set but blank"
            }
        }
        
        // Cache Status
        if (cacheDir.exists()) {
            def cacheSize = cacheDir.listFiles()?.length ?: 0
            def lastModified = new Date(cacheDir.lastModified())
            println "üì¶ NVD Cache: Found at ${cacheDir.absolutePath}"
            println "   Files: ${cacheSize}, Last updated: ${lastModified.format('yyyy-MM-dd HH:mm:ss')}"
        } else {
            println "üì¶ NVD Cache: Not found - will be created during first run"
        }
        
        println "=" * 60
        println ""
    }
    
    dependsOn dependencyCheckAnalyze
    
    doLast {
        println ""
        println "=" * 60
        println "‚úÖ Security scan completed"
        println "üìä Report: $buildDir/reports/security/dependency-check-report.html"
        println "üîç Review findings before proceeding with release"
        println "=" * 60
    }
}

// Validate NVD API key configuration without running full scan
tasks.register('checkNvdApiKey') {
    group = 'verification'
    description = 'Check NVD API key configuration and cache status'
    
    doLast {
        def apiKeyFromGradleProps = providers.gradleProperty('nvdApiKey').getOrNull()
        def apiKeyFromEnv = providers.environmentVariable('NVD_API_KEY').getOrNull()
        def cacheDir = file("${System.getProperty('user.home')}/.gradle/dependency-check-data")
        
        println "üîç NVD API Key Configuration Check"
        println "=" * 50
        
        // Check gradle property (could be from multiple sources)
        if (apiKeyFromGradleProps != null) {
            if (apiKeyFromGradleProps.trim().isEmpty()) {
                println "‚ö†Ô∏è  Gradle property: nvdApiKey found but is BLANK"
            } else {
                println "‚úÖ Gradle property: nvdApiKey found"
            }
        } else {
            println "‚ùå Gradle property: nvdApiKey not found"
        }
        
        // Check environment variable
        if (apiKeyFromEnv != null) {
            if (apiKeyFromEnv.trim().isEmpty()) {
                println "‚ö†Ô∏è  Environment variable: NVD_API_KEY found but is BLANK"
            } else {
                println "‚úÖ Environment variable: NVD_API_KEY found"
            }
        } else {
            println "‚ùå Environment variable: NVD_API_KEY not found"
        }
        
        // Effective configuration with precedence and validation
        def effectiveKey = null
        def effectiveSource = null
        
        if (apiKeyFromGradleProps != null && !apiKeyFromGradleProps.trim().isEmpty()) {
            effectiveKey = apiKeyFromGradleProps.trim()
            effectiveSource = "Gradle property"
        } else if (apiKeyFromEnv != null && !apiKeyFromEnv.trim().isEmpty()) {
            effectiveKey = apiKeyFromEnv.trim()
            effectiveSource = "Environment variable"
        }
        
        if (effectiveKey != null) {
            println "‚úÖ Effective configuration: API key will be used"
            println "   Source: ${effectiveSource}"
            
            // Log precedence if both are available
            if (apiKeyFromGradleProps != null && !apiKeyFromGradleProps.trim().isEmpty() && 
                apiKeyFromEnv != null && !apiKeyFromEnv.trim().isEmpty()) {
                println "   Note: Both sources found - Gradle property takes precedence"
            }
        } else {
            println "‚ö†Ô∏è  Effective configuration: No valid API key available"
            println "   ‚ö° Scans will be slower due to rate limiting"
            
            if (apiKeyFromGradleProps != null && apiKeyFromGradleProps.trim().isEmpty()) {
                println "   üí° Gradle property 'nvdApiKey' is blank - please set a valid key"
            }
            if (apiKeyFromEnv != null && apiKeyFromEnv.trim().isEmpty()) {
                println "   üí° Environment variable 'NVD_API_KEY' is blank - please set a valid key"
            }
        }
        
        // Cache status
        if (cacheDir.exists()) {
            def files = cacheDir.listFiles()
            def cacheSize = files?.length ?: 0
            if (cacheSize > 0) {
                def lastModified = new Date(cacheDir.lastModified())
                def totalSizeMB = files.collect { it.length() }.sum() / (1024 * 1024)
                println "üì¶ NVD Cache: ${cacheSize} files (${String.format('%.1f', totalSizeMB)} MB)"
                println "   Location: ${cacheDir.absolutePath}"
                println "   Last updated: ${lastModified.format('yyyy-MM-dd HH:mm:ss')}"
            } else {
                println "üì¶ NVD Cache: Directory exists but empty"
            }
        } else {
            println "üì¶ NVD Cache: Not found - will be created on first scan"
        }
        
        println "=" * 50
        
        // Recommendations
        if (effectiveKey == null) {
            println "üí° Recommendations:"
            println "   1. Get API key: https://nvd.nist.gov/developers/request-an-api-key"
            println "   2. Add to ~/.gradle/gradle.properties: nvdApiKey=your-key-here"
            println "   3. Or set environment variable: export NVD_API_KEY=your-key-here"
        } else if (apiKeyFromGradleProps == null && apiKeyFromEnv != null) {
            println "üí° Recommendation: Consider adding to ~/.gradle/gradle.properties for convenience"
        }
    }
}

// Generate plugin documentation automatically
tasks.register('generatePluginDocs') {
    description = "Generates comprehensive documentation for the plugin"
    group = "documentation"
    
    doLast {
        def docsDir = file("$projectDir/docs")
        docsDir.mkdirs()
        
        def descriptionFile = file("src/main/resources/plugin-description.md")
        def readmeContent = """# OpenAPI Model Generator Plugin

${descriptionFile.text}

## Installation

Add to your build.gradle:

```groovy
plugins {
    id 'com.guidedbyte.openapi-modelgen' version '2.1.0'
}
```
"""
        
        file("$docsDir/README.md").text = readmeContent
        
        println "Plugin documentation generated in: $docsDir/README.md"
    }
}

// Version management tasks
tasks.register('showVersion') {
    description = "Displays current plugin version"
    group = "versioning"
    
    doLast {
        println "Plugin Version: ${project.version}"
        println "Version Source: ${findProperty('version') ? 'gradle property' : 'git tag'}"
    }
}

tasks.register('validateVersion') {
    description = "Validates version format and compatibility"
    group = "versioning"
    
    doLast {
        def currentVersion = project.version.toString()
        
        // Validate semantic versioning format (official SemVer 2.0.0 regex)
        def semverPattern = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/
        if (!currentVersion.matches(semverPattern)) {
            throw new RuntimeException("Invalid version format: ${currentVersion}. Must follow semantic versioning (e.g., 1.2.3, 1.2.3-alpha.1, 1.2.3+build.1)")
        }
        
        // Check for development versions in release builds
        if (currentVersion.contains('SNAPSHOT') || currentVersion.contains('dirty')) {
            logger.warn("Development version detected: ${currentVersion}")
            if (gradle.taskGraph.hasTask(':publishPlugins')) {
                throw new RuntimeException("Cannot publish development version: ${currentVersion}")
            }
        }
        
        println "‚úÖ Version validation passed: ${currentVersion}"
    }
}

tasks.register('createRelease') {
    description = "Creates a new release tag and updates version"
    group = "versioning"
    dependsOn validateVersion
    
    doLast {
        def currentVersion = project.version.toString()
        
        if (currentVersion.contains('SNAPSHOT')) {
            throw new RuntimeException("Cannot create release from SNAPSHOT version: ${currentVersion}")
        }
        
        // Create git tag
        def tagName = "v${currentVersion}"
        def createTag = ['git', 'tag', '-a', tagName, '-m', "Release version ${currentVersion}"].execute()
        createTag.waitFor()
        
        if (createTag.exitValue() == 0) {
            println "‚úÖ Created release tag: ${tagName}"
            println "Next steps:"
            println "  1. git push origin ${tagName}"
            println "  2. ./gradlew publishPlugins"
        } else {
            throw new RuntimeException("Failed to create git tag: ${tagName}")
        }
    }
}

// Validate plugin before publishing
tasks.register('validatePlugin') {
    description = "Validates plugin is ready for publishing"
    group = "verification"
    dependsOn test, validateVersion
    
    doLast {
        // Check required files exist
        def requiredFiles = [
            '../README.md',
            '../CLAUDE.md', 
            'src/main/resources/plugin-description.md'
        ]
        
        requiredFiles.each { filePath ->
            if (!file(filePath).exists()) {
                throw new RuntimeException("Required file missing for publishing: ${filePath}")
            }
        }
        
        // Validate test coverage exists
        def testDir = file('src/test/java')
        def testFiles = testDir.listFiles({ File dir, String name -> name.endsWith('Test.java') } as FilenameFilter)
        
        println "‚úÖ Plugin validation passed - ready for publishing"
        println "  ‚Ä¢ ${testFiles?.length ?: 0} test classes found"
        println "  ‚Ä¢ All required documentation files present"
        println "  ‚Ä¢ Core functionality tests available (integration tests have known DSL limitations)"
        println "  ‚Ä¢ Plugin metadata configured"
        println "  ‚Ä¢ Version: ${project.version}"
    }
}

// Plugin publishing configuration
group = 'com.guidedbyte'
version = project.hasProperty('version') ? project.version : (findProperty('version') ?: gitVersion())
description = 'A comprehensive Gradle plugin for generating Java DTOs from OpenAPI specifications'

// Copy and process README with current version for publishing
tasks.register('processReadme', Copy) {
    from('../README.md')
    into('build/processed-docs')
    expand(version: project.version)
    
    // Ensure this runs before publishing
    publishPlugins.dependsOn(this)
}

// Configure publishing
publishing {
    publications {
        pluginMaven(MavenPublication) {
            artifactId = 'openapi-modelgen-plugin'
            pom {
                name = 'OpenAPI Model Generator Plugin'
                description = 'A comprehensive Gradle plugin for generating Java DTOs from OpenAPI specifications'
                url = 'https://github.com/ryansmith4/openapi-modelgen'
                
                licenses {
                    license {
                        name = 'Apache License 2.0'
                        url = 'https://www.apache.org/licenses/LICENSE-2.0'
                    }
                }
                
                developers {
                    developer {
                        id = 'ryansmith4'
                        name = 'Ryan Smith'
                        email = 'ryan.smith@guidedbyte.com'
                    }
                }
                
                scm {
                    connection = 'scm:git:git://github.com/ryansmith4/openapi-modelgen.git'
                    developerConnection = 'scm:git:ssh://github.com/ryansmith4/openapi-modelgen.git'
                    url = 'https://github.com/ryansmith4/openapi-modelgen'
                }
            }
        }
    }
}

// Dynamic version resolution
def gitVersion() {
    try {
        def process = ['git', 'describe', '--tags', '--always', '--dirty'].execute()
        process.waitFor()
        if (process.exitValue() == 0) {
            def tagOutput = process.text.trim()
            // Convert git tag to version (v1.2.3 -> 1.2.3, abc123 -> 1.0.0-SNAPSHOT)
            if (tagOutput.startsWith('v') && tagOutput.contains('.')) {
                return tagOutput.substring(1).replace('-dirty', '-SNAPSHOT')
            }
        }
    } catch (Exception e) {
        logger.warn("Git version detection failed: ${e.message}")
    }
    return "1.0.0-SNAPSHOT"
}

// Java compatibility
java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
    withSourcesJar()
    withJavadocJar()
}

// Configure JAR manifest with version information
jar {
    manifest {
        attributes(
            'Implementation-Title': 'OpenAPI Model Generator Plugin',
            'Implementation-Version': project.version,
            'Implementation-Vendor': 'GuidedByte Technologies Inc.',
            'Built-By': System.getProperty('user.name'),
            'Built-Date': new Date().format('yyyy-MM-dd HH:mm:ss'),
            'Built-JDK': System.getProperty('java.version'),
            'Built-Gradle': gradle.gradleVersion
        )
    }
}

gradlePlugin {
    website = 'https://github.com/ryansmith4/openapi-modelgen'
    vcsUrl = 'https://github.com/ryansmith4/openapi-modelgen.git'
    
    plugins {
        openapiModelgen {
            id = 'com.guidedbyte.openapi-modelgen'
            implementationClass = 'com.guidedbyte.openapi.modelgen.OpenApiModelGenPlugin'
            displayName = 'OpenAPI Model Generator'
            description = file("src/main/resources/plugin-description.md").text
            tags = ['openapi', 'code-generation', 'lombok', 'dto', 'models', 'java', 'spring', 'templates', 'customization']
        }
    }
}

